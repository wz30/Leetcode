## 55. Jump Game

## Solution 1
- backtrack 

```java
class Solution {
    public boolean canJump(int[] nums) {
        return recur(nums,  nums.length, 0);
    }
    boolean recur(int[] nums,  int n, int curIndex){
        if(curIndex >=nums.length-1) return true; 
        
        int num = nums[curIndex]; //# jump 
        boolean val = false;;
        for(int j = 1; j<=num; j++){
            val = val || recur(nums, n, curIndex+j);
            //if(recur(nums, n, curIndex+j)) return true; // as long as ther eis true, we have the path
        }
        
        return val;
    }
}
```

## Solution 2
- bottom up
```java
class Solution {
    int[] mem;
    public boolean canJump(int[] nums) {
        mem = new int[nums.length];
        return recur(nums,  nums.length, 0);
    }
    //reach some index
    boolean recur(int[] nums,  int n, int curIndex){
        if(curIndex >=nums.length-1) return true; 
        if(mem[curIndex]==1) return true;
        if(mem[curIndex]==-1) return false;
        int num = nums[curIndex]; //# jump 
        
        for(int j = 1; j<=num; j++){
            if(recur(nums, n, curIndex+j)){
                mem[curIndex] = 1;
                return true;
            }
        }
        mem[curIndex] = -1;
        return false;
    }
}
```


# Overviwq
- categorized the problem  into the pattern
##  Pattern: Top ‘K’ Elements，前K个系列
- [x] Kth Largest Number in an Array (medium) (unorderes array)
- [x] 973. K Closest Points to Origin (same idea as last problem) (unordered arrray)
- [x] 658. Find K Closest Elements (Even the problem title looks similar to last two problems, the solutions are different sicne the array is sorted)(binary search + two pointers)
- [x] Top K frequent number (unordered array)
- [x] 692. Top K Frequent Words (same solution + java comparator[inside the heap, we want to swap the larger string to the top])

- question about Top K pattern, the problem usuallu assume the Top k elements are unqiue, how to handle the duplicate cases


## Reference
- master method to analyze the recursive funtion: (https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2871/)
